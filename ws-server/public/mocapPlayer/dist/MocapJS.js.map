{"version":3,"sources":["webpack:///webpack/bootstrap 9df392a233ef4bd433a3","webpack:///./lib/MocapJS.js","webpack:///./lib/bvhCharacter.js","webpack:///./lib/parsers.js","webpack:///./lib/bvhParser.js","webpack:///./lib/bvhStreamParser.js","webpack:///./lib/c3dCharacter.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;AACA,uC;;;;;;ACFA;;AAEA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,cAAa,sBAAsB;AACnC;AACA,mBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAwC;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,KAAI;AACJ;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,KAAI,OAAO;AACX;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA;;AAEA,6CAA4C;;AAE5C;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA,KAAI;AACJ,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAuB;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAI,OAAO;AACX;AACA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA;;AAEA,6CAA4C;;AAE5C;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA,KAAI;AACJ,IAAG;AACH;AACA;;;AAGA,+B;;;;;;AC5XA;AACA;AACA;AACA,G;;;;;;ACHA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,UAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;;AAEA,wBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,cAAa;AACb;AACA,gCAA+B,kBAAkB;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kCAAiC;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA,UAAS,yBAAyB;;AAElC,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,UAAS,yBAAyB;AAClC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,qCAAqC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4DAA2D;AAC3D,4DAA2D;AAC3D,4DAA2D;;AAE3D,4DAA2D;AAC3D,4DAA2D;AAC3D,4DAA2D;AAC3D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAe,4BAA4B;AAC3C;AACA;;;;AAIA;AACA;AACA;AACA;AACA,aAAY,4BAA4B;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAc,yBAAyB;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,eAAc,4BAA4B;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kFAAiF;AACjF;;AAEA;AACA,oCAAmC;;AAEnC;AACA;;AAEA;AACA;AACA,gD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,cAAa;AACb;AACA;AACA;AACA,gDAA+C;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;;;;AAKA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA,4B;;;;;;AClZA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,kBAAkB,OAAO;AAC5C;AACA;AACA;AACA;;AAEA,wBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,cAAa,OAAO;AACpB;AACA,gCAA+B,kBAAkB;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kCAAiC;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA,UAAS,yBAAyB;;AAElC,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,UAAS,yBAAyB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,qCAAqC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4DAA2D;AAC3D,4DAA2D;AAC3D,4DAA2D;;AAE3D,4DAA2D;AAC3D,4DAA2D;AAC3D,4DAA2D;AAC3D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAe,4BAA4B;AAC3C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sBAAqB,OAAO;AAC5B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAgB,4BAA4B;AAC5C;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kBAAiB,SAAS;AAC1B;AACA,sBAAqB,yBAAyB;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAc,yBAAyB;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,eAAc,4BAA4B;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,gDAA+C;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAiD,0BAA0B;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,gDAA+C;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kC;;;;;;AClTA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAY,yBAAyB;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAY,wBAAwB;AACpC;AACA,cAAa,0BAA0B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,M;AACA;AACA;AACA,8B;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;;AAGA;AACA,YAAW,2BAA2B;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA,+B","file":"MocapJS.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 9df392a233ef4bd433a3\n **/","BVHCharacter = require('./bvhCharacter.js');\nC3DCharacter = require('./c3dCharacter.js');\nMocapParsers = require('./parsers.js');\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/MocapJS.js\n ** module id = 0\n ** module chunks = 0\n **/","var parsers = require('./parsers.js');\n\nvar BVHCharacter = BVHCharacter || {};\n\n\nBVHCharacter = function(n, jm, bm, jg, bg) {\n\tthis.name = n;\n\n\tthis.jointMaterial = jm;\n\tthis.boneMaterial = bm;\n\tthis.makeJointGeometryFCN = jg;\n\tthis.makeBoneGeometryFCN = bg;\n\n\tthis.bvh = [];\n\tthis.skeleton = new THREE.Group();\n\n\tthis.skelScale = 1;\n\tthis.jointMeshes = [];\n\tthis.boneMeshes = [];\n\tthis.rootMeshes = [];\n\n\tthis.originPosition = new THREE.Vector3(0, 0, 0);\n\n\tthis.ready = false;\n\tthis.frameTime = 1 / 30;\n\tthis.frameCount = 0;\n\tthis.animIndex = 0;\n\tthis.animStartTimeRef = 0;\n\tthis.animOffset = 0;\n\tthis.playing = true;\n\n\tthis.debug = true;\n\tthis.useWorker = true;\n\n\tthis.webSocket = [];\n\tthis.streamProtocol = \"BVHStream\";\n\tthis.keepStreamedFrames = true;\n\tthis.isStreaming = false;\n\n\tvar self = this;\n\n\t//\n\n\tthis.log = function(m) {\n\t\tif (self.debug)\n\t\t\tconsole.log(self.name + \": \" + m.toString());\n\t};\n\n\tthis.loadFromURL = function(url, callback) {\n\t\tself.log(\"Loading the mocap file ...\");\n\t\t//Pace.start();\n\t\treader = new parsers.bvhParser(this.name + \"READER\");\n\t\tthis.url = url;\n\t\treader.load(url, self.createSkel, self.fillFrames);\n\n\t\tthis.callb = callback;\n\t};\n\n\tthis.fillFrames = function() {\n\t\t// self.log(\"Ready!\");\n\t\tself.ready = true;\n\t\tself.playing = true;\n\n\t\tif (self.callb)\n\t\t\tself.callb();\n\t}\n\n\tthis.createSkel = function(data) {\n\t\tself.bvh = data;\n\t\tself.frameCount = data.frameCount;\n\t\tself.frameTime = data.frameTime;\n\n\t\tself.log(\"Mocap file loaded.\");\n\n\t\tself.log(\"Creating the WebGL Joints.\");\n\t\tself.buildSkelJoints(self.bvh.getSkeleton(), 0);\n\n\t\tself.log(\"Creating the WebGL Bones.\");\n\t\t(self.buildSkelBones(self.jointMeshes[0])).forEach(function(c) {\n\t\t\tself.rootMeshes.push(c);\n\t\t\tself.skeleton.add(c);\n\t\t});\n\t\tself.skeleton.add(self.jointMeshes[0]);\n\t\tself.setSkeletonScale(self.skelScale);\n\t\tself.setSkelUp();\n\t};\n\n\n\t// Beginning of the Stream Code\n\tthis.onHeaderReceived = function(data) {\n\t\tself.log(\"Loading the mocap header (skeleton) from the stream...\");\n\t\theaderReader = new parsers.bvhStreamParser();\n\t\theaderReader.readHeader(data, self.createSkel);\n\n\t\tif (self.callb)\n\t\t\tself.callb();\n\n\t\tPace.stop();\n\t}\n\n\tthis.onDataChunckReceived = function(rawFrames) {\n\t\tvar aa = [];\n\n\t\tfor (f = 1; f < rawFrames.length; f++) {\n\t\t\tvar parts = rawFrames[f].trim().split(\" \");\n\t\t\tfor (var j = 0; j < parts.length; j++)\n\t\t\t\tparts[j] = +parts[j];\n\t\t\taa.push(parts);\n\t\t}\n\t\tdiff = self.bvh.fillFrameArray(aa);\n\t\tself.frameCount = self.bvh.frameArray.length;\n\t\t\n\t\t\n\t\tif (!self.playing) {\n\t\t\tself.animStartTimeRef = Date.now();\n\t\t\t//  self.animOffset -= rawFrames.length;\n\t\t}\n\t\t/*\n\t\t// else\n\t\t// self.animOffset = self.animIndex;\n\t\tif (diff > 0)\n\t\t\tself.animOffset -= rawFrames.length + 1;\n\t\t// self.animIndex -= rawFrames.length; //math.max(0,math.min(rawFrames.length, self.bvh.bufferSize));\n\t\t*/\n\t\tself.fillFrames();\n\t\tPace.stop();\n\t}\n\n\tthis.loadFromStream = function(url, callback) {\n\t\tself.log(\"Connecting to the stream server...\");\n\t\tself.isStreaming = true;\n\t\tthis.callb = callback;\n\t\tself.webSocket = new WebSocket(url);\n\n\t\tself.webSocket.onerror = function(event) {\n\t\t\tself.log(\"Error connecting to the stream server \" + event.origin);\n\t\t};\n\n\t\tself.webSocket.onopen = function(event) {\n\t\t\tself.log(\"Connected to the stream server \" + event.origin);\n\t\t\tPace.stop();\n\t\t};\n\n\t\tself.webSocket.onmessage = function(event) {\n\t\t\t// I'm not doing much of a type and content checking here. Let's just trust the sender for now!\n\t\t\t// Protocol for header:\n\t\t\t// $HEADER$\n\t\t\t// BVH...\n\t\t\t// Protocl for data chunk with id#:\n\t\t\t// $FRAMES$id#$\n\n\t\t\tvar messageLines = event.data.split('\\n');\n\n\t\t\t// self.log(\"Received somthing!\");\n\t\t\t// self.log(\"The first line is : \" + messageLines[0]);\n\n\t\t\tif (messageLines.length < 1)\n\t\t\t\treturn;\n\n\t\t\tif (messageLines[0] == \"$HEADER$\") {\n\t\t\t\tself.onHeaderReceived(event.data);\n\n\t\t\t} else if (messageLines[0].startsWith(\"$FRAMES$\")) {\n\t\t\t\tchunckID = parseInt(messageLines[0].split(\"$\")[2]);\n\t\t\t\tself.onDataChunckReceived(messageLines, chunckID);\n\t\t\t}\n\t\t};\n\n\t};\n\n\tthis.requestFrames = function(i) {\n\t\tself.webSocket.send(\"$GETFRAMES\" + i + \"$\");\n\t}\n\n\t// End of the Stream Code\n\n\tthis.setOriginPosition = function(x, y, z) {\n\t\tself.originPosition.set(x, y, z);\n\t};\n\n\tthis.setSkeletonScale = function(s) {\n\t\tself.rootMeshes.forEach(function(c) {\n\t\t\tc.scale.set(s, s, s);\n\t\t});\n\t\tself.jointMeshes[0].scale.set(s, s, s);\n\t\tself.jointMeshes[0].position.multiplyScalar(s);\n\t};\n\n\tthis.buildSkelJoints = function(joint, parent) {\n\t\tvar jointMesh = new THREE.Mesh(self.makeJointGeometryFCN(joint.name, self.skelScale), self.jointMaterial);\n\t\tjointMesh.bvhIndex = joint.jointIndex;\n\t\tjointMesh.offsetVec = new THREE.Vector3(joint.offset[0], joint.offset[1], joint.offset[2]);\n\t\tjointMesh.name = joint.name;\n\t\tjointMesh.jointparent = parent;\n\t\tvar a, b, c;\n\t\tif (!joint.isEndSite()) {\n\t\t\ta = joint.channelNames[joint.channelNames.length - 3][0];\n\t\t\tb = joint.channelNames[joint.channelNames.length - 2][0];\n\t\t\tc = joint.channelNames[joint.channelNames.length - 1][0];\n\t\t}\n\t\tjointMesh.rotOrder = a + b + c;\n\t\tself.jointMeshes.push(jointMesh);\n\n\t\tjoint.children.forEach(function(child) {\n\t\t\tjointMesh.add(self.buildSkelJoints(child, 1));\n\t\t});\n\n\t\treturn jointMesh;\n\t};\n\n\tthis.buildSkelBones = function(jointMesh) {\n\t\tvar bones = [];\n\t\tjointMesh.children.forEach(function(childMesh) {\n\t\t\t// if (typeof childMesh.bvhIndex !== \"undefined\")\n\t\t\t{\n\t\t\t\tif (typeof childMesh.bvhIndex === \"undefined\")\n\t\t\t\t\treturn;\n\t\t\t\t// move origin (.translate)\n\t\t\t\t// rotate\n\t\t\t\t// translate (offset + position)\n\t\t\t\th = math.abs(childMesh.offsetVec.length());\n\t\t\t\tvar bgeometry = self.makeBoneGeometryFCN(\"\", childMesh.name, h, self.skelScale);\n\n\t\t\t\t//Begin - Working for MS\n\t\t\t\tif (childMesh.offsetVec.x < 0)\n\t\t\t\t\tbgeometry.rotateZ(3 * math.pi / 2);\n\t\t\t\telse if (childMesh.offsetVec.x > 0)\n\t\t\t\t\tbgeometry.rotateZ(-3 * math.pi / 2);\n\n\t\t\t\tif (childMesh.offsetVec.z < 0)\n\t\t\t\t\tbgeometry.rotateX(3 * math.pi / 2);\n\t\t\t\telse if (childMesh.offsetVec.z > 0)\n\t\t\t\t\tbgeometry.rotateX(-3 * math.pi / 2);\n\n\t\t\t\tbgeometry.translate(childMesh.offsetVec.x / 2, childMesh.offsetVec.y / 2, childMesh.offsetVec.z / 2);\n\n\t\t\t\t//END - Working for MS\n\n\n\t\t\t\tvar boneMesh = new THREE.Mesh(bgeometry, self.boneMaterial);\n\t\t\t\tboneMesh.joint = jointMesh;\n\t\t\t\tboneMesh.name = jointMesh.name + \" > \" + childMesh.name;\n\t\t\t\tself.boneMeshes.push(boneMesh);\n\t\t\t\t// scene.add(boneMesh);\n\t\t\t\tbones.push(boneMesh);\n\n\t\t\t\t(self.buildSkelBones(childMesh)).forEach(function(b) {\n\t\t\t\t\tboneMesh.add(b);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t\treturn bones;\n\t};\n\n\tthis.animFrame = function(frame) {\n\t\tif (frame >= self.frameCount){\n\t\t\tself.playing = false;\n\t\t\treturn;\n\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\tthis.jointMeshes[0].traverse(function(joint) {\n\t\t\tif (typeof joint.bvhIndex === \"undefined\")\n\t\t\t\treturn;\n\n\t\t\tvar bj = self.bvh.jointArray[joint.bvhIndex];\n\n\t\t\tvar offsetVec = joint.offsetVec;\n\t\t\tvar torad = Math.PI / 180;\n\t\t\tvar thisEuler = [];\n\n\n\t\t\tthisEuler = new THREE.Euler(\n\t\t\t\t(bj.channels[frame][bj.rotationIndex.x] * torad),\n\t\t\t\t(bj.channels[frame][bj.rotationIndex.y] * torad),\n\t\t\t\t(bj.channels[frame][bj.rotationIndex.z] * torad), joint.rotOrder);\n\n\n\t\t\tjoint.localRotMat = new THREE.Matrix4();\n\t\t\tjoint.localRotMat.makeRotationFromEuler(thisEuler);\n\t\t\tjoint.rotation.setFromRotationMatrix(joint.localRotMat);\n\n\t\t\tif (joint.jointparent != 0) {\n\t\t\t\tjoint.position.set(offsetVec.x, offsetVec.y, offsetVec.z);\n\t\t\t} else { // root\n\t\t\t\tjoint.position.set(\n\t\t\t\t\tbj.channels[frame][bj.positionIndex.x] * self.skelScale + self.originPosition.x,\n\t\t\t\t\tbj.channels[frame][bj.positionIndex.y] * self.skelScale + self.originPosition.y,\n\t\t\t\t\tbj.channels[frame][bj.positionIndex.z] * self.skelScale + self.originPosition.z);\n\t\t\t}\n\t\t});\n\n\t\tthis.rootMeshes.forEach(function(rootMesh) {\n\t\t\trootMesh.traverse(function(bone, index) {\n\t\t\t\tvar bj = self.bvh.jointArray[bone.joint.bvhIndex];\n\n\t\t\t\tvar offsetVec = new THREE.Vector3(bj.offset[0], bj.offset[1], bj.offset[2]);\n\n\t\t\t\tbone.rotation.copy(bone.joint.rotation); //setFromRotationMatrix(bone.joint.localRotMat);\n\n\t\t\t\tif (bone.parent.type === \"Group\") //root\n\t\t\t\t{\n\t\t\t\t\tbone.position.set(bj.channels[frame][bj.positionIndex.x] * self.skelScale + self.originPosition.x,\n\t\t\t\t\t\tbj.channels[frame][bj.positionIndex.y] * self.skelScale + self.originPosition.y,\n\t\t\t\t\t\tbj.channels[frame][bj.positionIndex.z] * self.skelScale + self.originPosition.z);\n\t\t\t\t} else {\n\t\t\t\t\tbone.position.set(offsetVec.x,\n\t\t\t\t\t\toffsetVec.y,\n\t\t\t\t\t\toffsetVec.z);\n\t\t\t\t}\n\n\t\t\t});\n\t\t});\n\t\t// if (self.isStreaming && frame >= self.frameCount - 5 ) {\n\t\t// \tself.animIndex = self.frameCount - 1;\n\t\t// \tself.playing = false;\n\n\t\t// }\n\t\t\n\t\tif (self.isStreaming) {\n\t\t\tself.log('Cutting from Frame ' + frame);\n\t\t\tconsole.log(self.frameCount);\n\t\t\tself.bvh.consumeFrames(frame);\n\t\t\tself.frameCount = self.bvh.frameArray.length;\n\t\t\t// console.log(self.frameCount);\n\t\t\tif (self.frameCount <= 0)\n\t\t\t\tself.playing = false;\n\t\t\t\t\n\t\t\tself.animOffset = 0;// self.animOffset - frame;\n\t\t\tself.animStartTimeRef = Date.now();\n\t\t}\n\t};\n\n\tthis.setSkelUp = function() {\n\t\tthis.jointMeshes[0].traverse(function(joint) {\n\t\t\tif (typeof joint.bvhIndex === \"undefined\")\n\t\t\t\treturn;\n\n\t\t\tvar bj = self.bvh.jointArray[joint.bvhIndex];\n\n\t\t\tvar offsetVec = joint.offsetVec;\n\t\t\tvar torad = Math.PI / 180;\n\t\t\tvar thisEuler = [];\n\n\t\t\tthisEuler = new THREE.Euler(0, 0, 0, joint.rotOrder);\n\n\t\t\tjoint.localRotMat = new THREE.Matrix4();\n\t\t\tjoint.localRotMat.makeRotationFromEuler(thisEuler);\n\t\t\tjoint.rotation.setFromRotationMatrix(joint.localRotMat);\n\n\t\t\tif (joint.jointparent != 0) {\n\t\t\t\tjoint.position.set(offsetVec.x, offsetVec.y, offsetVec.z);\n\t\t\t} else { // root\n\t\t\t\tjoint.position.set(self.originPosition.x, self.originPosition.y, self.originPosition.z);\n\t\t\t}\n\t\t});\n\n\t\tthis.rootMeshes.forEach(function(rootMesh) {\n\t\t\trootMesh.traverse(function(bone, index) {\n\t\t\t\tvar bj = self.bvh.jointArray[bone.joint.bvhIndex];\n\n\t\t\t\tvar offsetVec = new THREE.Vector3(bj.offset[0], bj.offset[1], bj.offset[2]);\n\n\t\t\t\tbone.rotation.copy(bone.joint.rotation); //setFromRotationMatrix(bone.joint.localRotMat);\n\n\t\t\t\tif (bone.parent.type === \"Group\") //root\n\t\t\t\t{\n\t\t\t\t\tbone.position.set(self.originPosition.x, self.originPosition.y, self.originPosition.z);\n\t\t\t\t} else {\n\t\t\t\t\tbone.position.set(offsetVec.x,\n\t\t\t\t\t\toffsetVec.y,\n\t\t\t\t\t\toffsetVec.z);\n\t\t\t\t}\n\n\t\t\t});\n\t\t});\n\t};\n};\n\n\nmodule.exports = BVHCharacter;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/bvhCharacter.js\n ** module id = 1\n ** module chunks = 0\n **/","module.exports ={\n    bvhParser: require('./bvhParser.js'),\n    bvhStreamParser: require('./bvhStreamParser.js')\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/parsers.js\n ** module id = 2\n ** module chunks = 0\n **/","// By Ankit\nvar BVHReader = function () {\n    this.load = function (url, callbackHeader, callbackFrameArray) {\n        $.get(url, function (str) {\n            \n            var dataReturn = parse(str);\n\n            \n            var jointStack = dataReturn[0];\n            var jointMap = dataReturn[1];\n            var jointArray = dataReturn[2];\n            var connectivityMatrix = dataReturn[3]\n            _bvh = new BVHReader.BVH.Skeleton(jointStack[0], jointMap, jointArray, dataReturn[3], dataReturn[4], dataReturn[5], []);\n            \n            if (callbackHeader)\n                callbackHeader(_bvh,'BVH');\n            console.log(\"Blah\");\n            _bvh.fillFrameArray(dataReturn[6]);\n\n            if (callbackFrameArray)\n                   callbackFrameArray();\n\n        });\n    };\n\n    function parse(str) {\n        var lines = str.split('\\n');\n        var jointStack = [];\n        var jointMap = {};\n        var jointArray = [];\n        var connectivityMatrix = [];\n        var frameCount, frameTime, frameArray = [];\n        var i = 0;\n        //parse structure\n        for (i = 1; i < lines.length; i++) {\n            if (!parseLine(lines[i], jointStack, jointMap, jointArray, connectivityMatrix)) {\n                break;\n            }\n        }\n\n        for (i = i + 1; i < lines.length; i++) {\n            var line = lines[i].trim();\n            //when encountering last line\n            if (line === \"\")\n                break;\n            if (line.indexOf(\"Frames\") === 0) {\n                frameCount = +(line.split(/\\b/)[2]);\n            } else if (line.indexOf(\"Frame Time\") === 0) {\n                frameTime = +( line.substr(line.indexOf(\":\") + 1).trim() )\n            } else {\n                var parts = line.split(\" \");\n                for (var j = 0; j < parts.length; j++)\n                    parts[j] = +parts[j];\n                frameArray.push(parts);\n            }\n        }\n\n        //parse motion\n        return [jointStack, jointMap, jointArray, connectivityMatrix, frameCount, frameTime, frameArray];\n    }\n\n    //parses individual line in the bvh file.\n    var parseLine = function (line, jointStack, jointMap, jointArray, connectivityMatrix) {\n        line = line.trim();\n        if (line.indexOf(\"ROOT\") > -1 || line.indexOf(\"JOINT\") > -1 || line.indexOf(\"End\") > -1) {\n            var parts = line.split(\" \");\n            var title = parts[1]; //temporary variable to be used after creating the joint object\n            parts[1] = parts[1] + \"-\" + jointArray.length;\n            var joint = new BVHReader.BVH.Joint(parts[1]);\n            joint.title = title;\n            jointStack.push(joint);\n\n            joint.jointIndex = Object.keys(jointMap).length;\n            jointMap[parts[1]] = joint;\n            jointArray.push(joint);\n            //if the joint is not an end site\n            if( line.indexOf(\"End\") != 0 ){\n                if (jointArray.length == 1) {\n                    joint.channelOffset = 0;\n                } else {\n                    joint.channelOffset = jointArray[jointArray.length - 2].channelOffset + jointArray[jointArray.length - 2].channelLength;\n                }\n            }else{\n                //channelLength is 0 for end joints\n                joint.channelLength = 0;\n                joint.channelOffset = jointArray[jointArray.length - 2].channelOffset + jointArray[jointArray.length - 2].channelLength;\n            }\n\n        } else if (line.indexOf(\"{\") === 0) {\n\n        } else if (line.indexOf(\"OFFSET\") === 0) {\n            var parts = line.split(\" \");\n            jointStack[jointStack.length - 1][\"offset\"] = parts.slice(1);\n            for(x in jointStack[jointStack.length - 1][\"offset\"]){\n                jointStack[jointStack.length - 1][\"offset\"][x] = +jointStack[jointStack.length - 1][\"offset\"][x]\n            }\n        } else if (line.indexOf(\"CHANNELS\") === 0) {\n            var parts = line.split(\" \");\n            jointStack[jointStack.length - 1].setChannelNames(parts.slice(2));\n            jointStack[jointStack.length - 1][\"channelLength\"] = +parts[1];\n        } else if (line.indexOf(\"}\") === 0) {\n            if (jointStack.length > 1) {\n                child = jointStack.pop();\n                jointStack[jointStack.length - 1].children.push(child);\n                child.parent = jointStack[jointStack.length - 1];\n\n                connectivityMatrix.push([child.parent, child])\n\n                // if(!connectivityMatrix[child.name]){\n                //     connectivityMatrix[child.name] = {}\n                // }\n                // connectivityMatrix[child.name][child.parent.name] = 1;\n\n                // if(!connectivityMatrix[child.parent.name]){\n                //     connectivityMatrix[child.parent.name] = {}\n                // }\n                // connectivityMatrix[child.parent.name][child.name] = 1;\n            }\n        } else if (line.indexOf(\"MOTION\") == 0) {\n            return false;\n        }\n\n        return true;\n    };\n};\n\nBVHReader.BVH = BVHReader.BVH || {};\n\nBVHReader.BVH.Joint = function (name, index) {\n\n    this.name = name;\n    this.children = [];\n    this.isEndSite = function () {\n        return this.children.length == 0;\n    };\n    this.rotationIndex = {};\n    this.positionIndex = {};\n\n    this.getChannels = function () {\n        var allChannels = [];\n        for (i = 0; i < this.skeleton.frameArray.length; i++) {\n            allChannels.push(this.getChannelsAt(i));\n        }\n        return allChannels;\n    };\n    this.getChannelsAt = function (frameNum) {\n        var channelsAtFrame = this.skeleton.frameArray[frameNum];\n        return channelsAtFrame.slice(this.channelOffset, this.channelOffset + this.channelLength);\n    };\n\n    this.setChannelNames = function (nameArr){\n        this.channelNames = nameArr;\n        for(i in this.channelNames){\n            var name = this.channelNames[i];\n            switch(name){\n                case \"Xposition\": this.positionIndex.x = i; break;\n                case \"Yposition\": this.positionIndex.y = i; break;\n                case \"Zposition\": this.positionIndex.z = i; break;\n\n                case \"Xrotation\": this.rotationIndex.x = i; break;\n                case \"Yrotation\": this.rotationIndex.y = i; break;\n                case \"Zrotation\": this.rotationIndex.z = i; break;\n            }\n        }\n    }\n};\n\nBVHReader.BVH.Skeleton = function (root, map, arr, connectivityMatrix, frameCount, frameTime, frameArray) {\n    thisSkeleton = this;\n    this.root = root;\n    this.jointMap = map;\n    this.jointArray = arr;\n    this.connectivityMatrix = connectivityMatrix;\n    this.frameCount = frameCount;\n    this.frameTime = frameTime;\n    this.frameArray = frameArray;\n\n    for (i = 0; i < this.jointArray.length; i++) {\n        this.jointArray[i].skeleton = thisSkeleton;\n    }\n\n\n\n    this.fillFrameArray = function (fa) {\n        this.frameArray = fa;\n        this.frameCount = fa.length;\n            //all the structures are ready. let's calculate the positions\n    for(j=0; j < this.jointArray.length; j++){\n        var joint = this.jointArray[j];\n        updateWithPositions(joint);\n    }\n    }\n\n    this.getChannels = function () {\n        return frameArray;\n    };\n    this.getChannelsAt = function (frameNum) {\n    \t//How do I know which column is what?\n        //Why do you need the column index?\n        return frameArray[frameNum];\n    };\n    this.getFrameRate = function () {\n        return frameCount / frameTime;\n    };\n    this.getSkeleton = function () {\n        return root;\n    };\n\n    this.getHeadJoint = function () {\n    \t// do a quick search in the joint names to see if any of them matches head, else return the something!!!!\n        return jointMap[\"Head\"];\n    };\n    this.getPositionsAt = function (frameNum) {\n    \t//for each joint, calculate its position in XYZ\n        //return an array of joints, each with .x, .y, and .z properties\n    \tposFrame = [];\n\n    \tfor (j=0;j<this.jointArray.length;j++) {\n    \t\tposFrame.push(this.jointArray[j].positions[frameNum]);\n    \t}\n\n    \tposFrame = posFrame.map(function(d) {\n\t\t\treturn {\n\t\t\t\tx : d[0],\n\t\t\t\ty : d[1],\n\t\t\t\tz : d[2],\n\t\t\t};\n\t\t});\n\n        return posFrame;\n    };\n    this.getTPose = function () {\n    \t// This function is basically the same as the getPositionsAt except that all the rotations will be 0\n        console.log(\"Not yet implemented\");\n    };\n\n    function updatePositions(rootOffset, removeRoot, orientation, camera) {\n      //TODO: compelte the specification of this\n\n      for(j=0; j < this.jointArray.length; j++){\n          var joint = this.jointArray[j];\n          updateWithPositions(joint);\n      }\n    }\n\n    function updateWithPositions(joint){\n        var channelNames = joint.channelNames;\n        joint.channels = joint.getChannels();\n        joint.rotations = [];\n        joint.positions = [];\n        joint.rotmat = [];\n        for(i in joint.channels){\n            var channel = joint.channels[i];\n            var xpos = channel[joint.positionIndex.x] || 0,\n            ypos =  channel[joint.positionIndex.y] || 0,\n            zpos =  channel[joint.positionIndex.z] || 0,\n            xangle =  deg2rad(channel[joint.rotationIndex.x] || 0),\n            yangle =  deg2rad(channel[joint.rotationIndex.y] || 0),\n            zangle= deg2rad(channel[joint.rotationIndex.z] || 0);\n\n            // var rotMatrix = math.transpose(getRotationMatrix(xangle, yangle, zangle, \"xyz\"));\n            // var rotMatrix = getRotationMatrix1(xangle, yangle, zangle, \"xyz\"); //this also works\n            var posMatrix = [xpos, ypos, zpos];\n\n            if(joint.parent){\n            \t  posMatrix = [0,0,0];  //At least for the bvhs that we have, this should be set to 0\n\n                // var t = vectorAdd(joint.offset, posMatrix);\n                // var u = matrixMultiply(t, joint.parent.rotations[i]);\n\n                // joint.positions[i] = vectorAdd(u, joint.parent.positions[i]);\n                // joint.rotations[i] = matrixMultiply( rotMatrix, joint.parent.rotations[i]);\n                // joint.rotmat[i] = rotMatrix; \n\n                 if (i==0 && (joint.name ==  \"Spine\" || joint.name == \"L_Femur\")) {\n                    /*console.log(\"head's rot mat: \");\n                    console.log(joint.rotations[i]);\n                    console.log(t);\n                    console.log(u);\n\n                    console.log(\"x: \"+xangle + \"y: \"+yangle + \"z: \"+zangle );\n                    console.log(posMatrix);\n                    */\n                }\n\n            }else{\n                //its the root\n                // joint.rotations[i] = rotMatrix;\n                // joint.rotmat[i] = rotMatrix;\n                joint.positions[i] = posMatrix;//vectorAdd(joint.offset , posMatrix);\n                // ^ we can safely ignore the root's offset\n            }\n        }\n    }\n\n    function deg2rad(deg){\n        return deg * (Math.PI/180);\n    }\n\n\n    function getRotationMatrix(alpha, beta, gamma) {\n\n    //inputs are the intrinsic rotation angles in RADIANTS\n    var ca = Math.cos(alpha),\n    \tsa = Math.sin(alpha),\n\n    \tcb = Math.cos(beta),\n    \tsb = Math.sin(beta),\n\n    \tcg = Math.cos(gamma),\n    \tsg = Math.sin(gamma),\n\n    Rx = [[1, 0, 0], [0, ca, -sa], [0, sa, ca]];\n\n    Ry = [[cb, 0, sb], [0, 1, 0], [-sb, 0, cb]];\n\n    Rz = [[cg, -sg, 0], [sg, cg, 0], [0,    0,   1]];\n\n\n\n\n    var Rzm = math.matrix(Rz);\n    var Rym = math.matrix(Ry);\n    var Rxm = math.matrix(Rx);\n\n    var tt = math.multiply(Rzm, Rym);\n\n    return  math.multiply(tt,Rxm).toArray();\n    //rotationMatrix = math. //Rz*Ry*Rx;\n\n    //     R = Rx*Ry*Rz;\n\t}\n\n    function getRotationMatrix1 (xangle, yangle, zangle, order){\n        var c1 = Math.cos(xangle),\n        c2 = Math.cos(yangle),\n        c3 = Math.cos(zangle),\n        s1 = Math.sin(xangle),\n        s2 = Math.sin(yangle),\n        s3 = Math.sin(zangle);\n\n        if(order === undefined || order.trim() === \"\"){\n            order = \"zxy\";\n        }\n\n        var rotMat = [\n            [1,0,0],\n            [0,1,0],\n            [0,0,1]\n        ];\n\n        switch(order){\n            case \"___zxy\":\n                rotMat = [\n                    [c2*c3-s1*s2*s3, c2*s3+s1*s2*c3, -s2*c1],\n                    [-c1*s3, c1*c3, s1],\n                    [s2*c3+c2*s1*s3, s2*s3-c2*s1*c3, c2*c1]\n                ];\n            break;\n            default:\n              for (o in order){\n                var axis = order[o];\n                var t;\n                switch(axis){\n                    case \"x\":\n                        t = [\n                                [1, 0, 0],\n                                [0,  c1, s1],\n                                [0, -s1, c1],\n                            ]\n                        break;\n                    case \"y\":\n                        t = [\n                                [c2,0,-s2],\n                                [0,1,0],\n                                [s2,0,c2]\n                            ]\n                        break;\n                    case \"z\":\n                        t = [[c3,s3,0],[-s3,c3,0],[0,0,1]]\n                        break;\n                }\n\n                rotMat = matrixMultiply(t, rotMat)\n              }\n          }\n\n        return rotMat;\n    }\n};\n\nfunction vectorAdd(a, b){\n    return math.add(math.matrix(a), math.matrix(b)).toArray();\n}\n\nfunction matrixMultiply(m1, m2) {\n    var a = math.matrix(m1);\n    var b = math.matrix(m2);\n    return math.multiply(a, b).toArray();\n}\n\n\nmodule.exports = BVHReader;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/bvhParser.js\n ** module id = 3\n ** module chunks = 0\n **/","// BVH parser by Ankit\n// Stream by Omid\n\n\nvar BVHStreamParser = function () {\n    this.readHeader = function (str, callback) {\n            var dataReturn = parseHeader(str);\n            var jointStack = dataReturn[0];\n            var jointMap = dataReturn[1];\n            var jointArray = dataReturn[2];\n            var connectivityMatrix = dataReturn[3]\n            if (callback)\n                callback(new BVHStreamParser.BVH.Skeleton(jointStack[0], jointMap, jointArray, dataReturn[3], 0, dataReturn[5], dataReturn[6]),'BVH');\n    };\n\n    function parseHeader(str) {\n        var lines = str.split('\\n');\n        var jointStack = [];\n        var jointMap = {};\n        var jointArray = [];\n        var connectivityMatrix = [];\n        var frameCount, frameTime, frameArray = [];\n        var i = 0;\n        //parse structure\n        for (i = 2; i < lines.length; i++) { //  start from 2 to skip the $HEADER$ command\n            if (!parseLine(lines[i], jointStack, jointMap, jointArray, connectivityMatrix)) {\n                break;\n            }\n        }\n\n        for (i = i + 1; i < lines.length; i++) {\n            var line = lines[i].trim();\n            //when encountering last line\n            if (line === \"\")\n                break;\n            if (line.indexOf(\"Frames\") === 0) {\n                frameCount = +(line.split(/\\b/)[2]);\n            } else if (line.indexOf(\"Frame Time\") === 0) {\n                frameTime = +( line.substr(line.indexOf(\":\") + 1).trim() )\n            } else { /// maybe this should be removed\n                var parts = line.split(\" \");\n                for (var j = 0; j < parts.length; j++)\n                    parts[j] = +parts[j];\n                frameArray.push(parts);\n            }\n        }\n\n        //parse motion\n        return [jointStack, jointMap, jointArray, connectivityMatrix, frameCount, frameTime, frameArray];\n    }\n\n    //parses individual line in the bvh file.\n    var parseLine = function (line, jointStack, jointMap, jointArray, connectivityMatrix) {\n        line = line.trim();\n        if (line.indexOf(\"ROOT\") > -1 || line.indexOf(\"JOINT\") > -1 || line.indexOf(\"End\") > -1) {\n            var parts = line.split(\" \");\n            var title = parts[1]; //temporary variable to be used after creating the joint object\n            parts[1] = parts[1] + \"-\" + jointArray.length;\n            var joint = new BVHStreamParser.BVH.Joint(parts[1]);\n            joint.title = title;\n            jointStack.push(joint);\n\n            joint.jointIndex = Object.keys(jointMap).length;\n            jointMap[parts[1]] = joint;\n            jointArray.push(joint);\n            //if the joint is not an end site\n            if( line.indexOf(\"End\") != 0 ){\n                if (jointArray.length == 1) {\n                    joint.channelOffset = 0;\n                } else {\n                    joint.channelOffset = jointArray[jointArray.length - 2].channelOffset + jointArray[jointArray.length - 2].channelLength;\n                }\n            }else{\n                //channelLength is 0 for end joints\n                joint.channelLength = 0;\n                joint.channelOffset = jointArray[jointArray.length - 2].channelOffset + jointArray[jointArray.length - 2].channelLength;\n            }\n\n        } else if (line.indexOf(\"{\") === 0) {\n\n        } else if (line.indexOf(\"OFFSET\") === 0) {\n            var parts = line.split(\" \");\n            jointStack[jointStack.length - 1][\"offset\"] = parts.slice(1);\n            for(x in jointStack[jointStack.length - 1][\"offset\"]){\n                jointStack[jointStack.length - 1][\"offset\"][x] = +jointStack[jointStack.length - 1][\"offset\"][x]\n            }\n        } else if (line.indexOf(\"CHANNELS\") === 0) {\n            var parts = line.split(\" \");\n            jointStack[jointStack.length - 1].setChannelNames(parts.slice(2));\n            jointStack[jointStack.length - 1][\"channelLength\"] = +parts[1];\n        } else if (line.indexOf(\"}\") === 0) {\n            if (jointStack.length > 1) {\n                child = jointStack.pop();\n                jointStack[jointStack.length - 1].children.push(child);\n                child.parent = jointStack[jointStack.length - 1];\n\n                connectivityMatrix.push([child.parent, child])\n            }\n        } else if (line.indexOf(\"MOTION\") == 0) {\n            return false;\n        }\n\n        return true;\n    };\n};\n\nBVHStreamParser.BVH = BVHStreamParser.BVH || {};\n\nBVHStreamParser.BVH.Joint = function (name, index) {\n\n    this.name = name;\n    this.children = [];\n    this.isEndSite = function () {\n        return this.children.length == 0;\n    };\n    this.rotationIndex = {};\n    this.positionIndex = {};\n\n    this.getChannels = function () {\n        var allChannels = [];\n        for (i = 0; i < this.skeleton.frameArray.length; i++) {\n            allChannels.push(this.getChannelsAt(i));\n        }\n        return allChannels;\n    };\n    this.getChannelsAt = function (frameNum) {\n        var channelsAtFrame = this.skeleton.frameArray[frameNum];\n        return channelsAtFrame.slice(this.channelOffset, this.channelOffset + this.channelLength);\n    };\n\n    this.setChannelNames = function (nameArr){\n        this.channelNames = nameArr;\n        for(i in this.channelNames){\n            var name = this.channelNames[i];\n            switch(name){\n                case \"Xposition\": this.positionIndex.x = i; break;\n                case \"Yposition\": this.positionIndex.y = i; break;\n                case \"Zposition\": this.positionIndex.z = i; break;\n\n                case \"Xrotation\": this.rotationIndex.x = i; break;\n                case \"Yrotation\": this.rotationIndex.y = i; break;\n                case \"Zrotation\": this.rotationIndex.z = i; break;\n            }\n        }\n    }\n};\n\nBVHStreamParser.BVH.Skeleton = function (root, map, arr, connectivityMatrix, frameCount, frameTime, frameArray) {\n    thisSkeleton = this;\n    this.root = root;\n    this.jointMap = map;\n    this.jointArray = arr;\n    this.connectivityMatrix = connectivityMatrix;\n    this.frameCount = frameCount;\n    this.frameTime = frameTime;\n    this.frameArray = frameArray;\n    this.bufferSize = 500;\n\n    for (i = 0; i < this.jointArray.length; i++) {\n        this.jointArray[i].skeleton = thisSkeleton;\n    }\n\n    this.fillFrameArray = function (fa) {\n        this.frameArray.push.apply(this.frameArray,fa);\n        //this.frameArray.push.apply(this.frameArray,fa);\n        \n        diff = this.frameArray.length - this.bufferSize;\n        // console.log('diff = ' + diff);\n        \n        /*\n        if (diff > 0) \n            for (i=0;i<diff;i++)\n                this.frameArray.shift();\n\n        this.frameCount = this.frameArray.length;\n        */\n         \n        if (diff > 0) \n            addedCount = this.frameCount;\n        else\n            addedCount = fa.length;\n\n        for(j=0; j < this.jointArray.length; j++){\n            var joint = this.jointArray[j];\n            updateWithPositionsSinceLast(joint, addedCount);\n        }\n        \n        return diff;\n    }\n\n    this.consumeFrames = function (index) {\n        for (i=0;i<=index;i++) {\n            this.frameArray.shift();\n            for (j=0;j<this.jointArray.length;j++)\n                this.jointArray[j].channels.shift();\n        }\n        this.frameCount = this.frameArray.length;\n    }\n\n    this.getChannels = function () {\n        return frameArray;\n    };\n    this.getChannelsAt = function (frameNum) {\n    \t//How do I know which column is what?\n        //Why do you need the column index?\n        return frameArray[frameNum];\n    };\n    this.getFrameRate = function () {\n        return frameCount / frameTime;\n    };\n    this.getSkeleton = function () {\n        return root;\n    };\n\n    this.getHeadJoint = function () {\n    \t// do a quick search in the joint names to see if any of them matches head, else return the something!!!!\n        return jointMap[\"Head\"];\n    };\n    this.getPositionsAt = function (frameNum) {\n    \t//for each joint, calculate its position in XYZ\n        //return an array of joints, each with .x, .y, and .z properties\n    \tposFrame = [];\n\n    \tfor (j=0;j<this.jointArray.length;j++) {\n    \t\tposFrame.push(this.jointArray[j].positions[frameNum]);\n    \t}\n\n    \tposFrame = posFrame.map(function(d) {\n\t\t\treturn {\n\t\t\t\tx : d[0],\n\t\t\t\ty : d[1],\n\t\t\t\tz : d[2],\n\t\t\t};\n\t\t});\n\n        return posFrame;\n    };\n    this.getTPose = function () {\n    \t// This function is basically the same as the getPositionsAt except that all the rotations will be 0\n        console.log(\"Not yet implemented\");\n    };\n\n    function updatePositions(rootOffset, removeRoot, orientation, camera) {\n      //TODO: compelte the specification of this\n\n      for(j=0; j < this.jointArray.length; j++){\n          var joint = this.jointArray[j];\n          updateWithPositions(joint);\n      }\n    }\n\n    function updateWithPositions(joint){\n        var channelNames = joint.channelNames;\n        joint.channels = joint.getChannels();\n        joint.rotations = [];\n        joint.positions = [];\n        joint.rotmat = [];\n        for(i in joint.channels){\n            var channel = joint.channels[i];\n            var xpos = channel[joint.positionIndex.x] || 0,\n            ypos =  channel[joint.positionIndex.y] || 0,\n            zpos =  channel[joint.positionIndex.z] || 0;\n            // xangle =  deg2rad(channel[joint.rotationIndex.x] || 0),\n            // yangle =  deg2rad(channel[joint.rotationIndex.y] || 0),\n            // zangle= deg2rad(channel[joint.rotationIndex.z] || 0);\n\n            var posMatrix = [xpos, ypos, zpos];\n\n            if(!joint.parent){\n                //its the root\n                joint.positions[i] = posMatrix;//vectorAdd(joint.offset , posMatrix);\n                // ^ we can safely ignore the root's offset\n            }\n        }\n    }\n\n    function updateWithPositionsSinceLast(joint, addedCount){\n        var channelNames = joint.channelNames;\n        joint.channels = joint.getChannels();\n        joint.rotations = [];\n        joint.positions = [];\n        joint.rotmat = [];\n        for(i=joint.channels.length - addedCount;i < joint.channels.length; i++){\n            var channel = joint.channels[i];\n            var xpos = channel[joint.positionIndex.x] || 0,\n            ypos =  channel[joint.positionIndex.y] || 0,\n            zpos =  channel[joint.positionIndex.z] || 0;\n            // xangle =  deg2rad(channel[joint.rotationIndex.x] || 0),\n            // yangle =  deg2rad(channel[joint.rotationIndex.y] || 0),\n            // zangle= deg2rad(channel[joint.rotationIndex.z] || 0);\n\n            var posMatrix = [xpos, ypos, zpos];\n\n            if(!joint.parent){\n                //its the root\n                joint.positions[i] = posMatrix;//vectorAdd(joint.offset , posMatrix);\n                // ^ we can safely ignore the root's offset\n            }\n        }\n    }\n\n    function deg2rad(deg){\n        return deg * (Math.PI/180);\n    }\n};\n\nmodule.exports = BVHStreamParser;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/bvhStreamParser.js\n ** module id = 4\n ** module chunks = 0\n **/","var C3DCharacter = C3DCharacter || {};\n\nC3DCharacter = function(n, jm, jg){\n\tthis.name = n;\n\t\n\tthis.markerMaterial = jm;\n\tthis.makeMarkerGeometryFCN = jg;\n\n\tthis.originPosition = new THREE.Vector3(0,0,0);\n\n\tthis.markerdata = [];\n\tthis.ready = false;\n\tthis.scale = 0.1;\n\tthis.markerMeshes = [];\n\n\tthis.frameTime = 1/30;\n\tthis.frameCount = 0;\n\n\tthis.animIndex = 0;\n\tthis.animStartTimeRef = 0;\n\tthis.animOffset = 0;\n\tthis.playing = true;\n\n\tthis.debug = true;\n\n\tvar self = this;\n\n\t//\n\n\tthis.log = function(m) {\n\t\tif (self.debug)\n\t\t\tconsole.log(self.name + \": \"+m.toString());\n\t};\n\n\tthis.loadFromURL = function(url, callback) {\n\t\tself.log(\"Loading the mocap file ...\");\n\t\tPace.start();\n\t\turl2 = \"http://www.sfu.ca/~oalemi/webglplayer/\" + url;\n\t\tself.url = url;\n\t\tPapa.parse(url2, {\n\t\tworker: true,\n\t\tdelimiter: \",\",\t\n\t\tdynamicTyping: true,\n\t\tdownload: true,\n\t\theader: false,\n\t\tcomplete: function(results) {\n\t\t\t//self.markerdata = results.data;\n\n\t\t\tfor (i=0;i<results.data[0].length;i++) {\n\t\t\t\tvar markerMesh = new THREE.Mesh(self.makeMarkerGeometryFCN(results.data[0][i], self.scale), self.markerMaterial);\n\t\t\t\tmarkerMesh.markerIndex = i;\n\t\t\t\tmarkerMesh.name = results.data[0][i];\n\t\t\t\tscene.add(markerMesh);\n\t\t\t\tself.markerMeshes.push(markerMesh);\n\t\t\t}\n\n\t\t\tself.markerNames = results.data[0];\n\t\t\tfor (f=1;f<results.data.length-3;f+=3) {\n\t\t\t\tself.markerdata[(f-1)/3] = [];\n\t\t\t\tfor (m=0;m<self.markerNames.length;m++) {\n\t\t\t\t\tmarker = [];\n\t\t\t\t\tmarker.x = results.data[f][m];\n\t\t\t\t\tmarker.y = results.data[f+1][m];\n\t\t\t\t\tmarker.z = results.data[f+2][m];\n\t\t\t\t\tmarker.name = self.markerNames[m];\n\t\t\t\t\tself.markerdata[(f-1)/3].push(marker);\n\t\t\t\t} \n\t\t\t}\n\t\t\tself.frameCount = self.markerdata.length;\n\t\t\tself.log(\"Done parsing!\");\t\n\t\t\tself.ready = true;\n\t\t\tif (callback)\n\t\t\t\tcallback();\n\t\t}\n\t\t});\n\t};\n\n\tthis.setOriginPosition = function (x, y, z) {\n\t\tself.originPosition.set(x,y,z);\n\t};\n\n\tthis.setSkeletonScale = function(s) {\n\t\tself.rootMeshes.forEach(function (c) {\n\t\t\tc.scale.set(s,s,s);\n\t\t});\n\t\tself.jointMeshes[0].scale.set(s,s,s);\n\t\tself.jointMeshes[0].position.multiplyScalar(s);\n\t};\n\n\n\tthis.animFrame = function (frame) {\n\t\tfor (m=0;m<self.markerMeshes.length; m++) {\n\t\t\tself.markerMeshes[m].position.set(self.markerdata[frame][m].x * self.scale + self.originPosition.x,\n\t\t\t\t\t\t\t\t\t\t \t  self.markerdata[frame][m].y * self.scale + self.originPosition.y,\n\t\t\t\t\t\t\t\t\t\t \t  self.markerdata[frame][m].z * self.scale + self.originPosition.z);\n\t\t}\n\t};\n};\n\nmodule.exports = C3DCharacter;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/c3dCharacter.js\n ** module id = 5\n ** module chunks = 0\n **/"],"sourceRoot":""}